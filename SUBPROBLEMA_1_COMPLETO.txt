================================================================================
            SUBPROBLEMA 1: ANALISIS DE DATOS - COMPLETADO ✓
================================================================================

OBJETIVO:
  Ordenar individuos por múltiples criterios usando tres algoritmos diferentes
  con complejidad garantizada de O(n log n)

================================================================================
                          IMPLEMENTACION
================================================================================

ALGORITMOS IMPLEMENTADOS:

1. MERGESORT - O(n log n) GARANTIZADO
   ─────────────────────────────────
   Archivo: analisis_datos.c
   Funciones:
     - merge_sort_helper(): Divide recursivamente el array en mitades
     - merge(): Combina dos subarrays ordenados
   
   Complejidad:
     - Tiempo: O(n log n) garantizado (T(n) = 2*T(n/2) + O(n))
     - Espacio: O(n) por los arrays temporales L y R
   
   Características:
     - Estable (mantiene orden relativo de elementos iguales)
     - Divide y conquista (top-down)
     - Ideal para grandes datasets
     - Requiere memoria adicional

2. QUICKSORT - O(n log n) PROMEDIO
   ────────────────────────────────
   Archivo: analisis_datos.c
   Funciones:
     - quick_sort_helper(): Recursión con particionamiento
     - partition(): Selecciona pivot y particiona array
   
   Complejidad:
     - Tiempo promedio: O(n log n)
     - Tiempo peor caso: O(n²) (cuando pivot es siempre extremo)
     - Espacio: O(log n) por la pila de recursión
   
   Características:
     - No estable (puede cambiar orden de elementos iguales)
     - In-place (sin memoria adicional apreciable)
     - Quicksort iterativo está optimizado in-cache
     - Muy usado en práctica por su rendimiento

3. HEAPSORT - O(n log n) GARANTIZADO
   ──────────────────────────────────
   Archivo: analisis_datos.c
   Funciones:
     - heap_sort(): Construye Max-Heap y extrae elementos
     - heapify_down(): Mantiene propiedad del heap
   
   Complejidad:
     - Tiempo: O(n log n) garantizado
       * Construcción: O(n)
       * Extracción: O(n log n) = n * log(n)
     - Espacio: O(1) in-place
   
   Características:
     - No estable
     - In-place
     - Rendimiento predecible
     - Menos cache-friendly que QuickSort

================================================================================
                        CRITERIOS DE ORDENAMIENTO
================================================================================

Se implementan 3 criterios de ordenamiento:

1. ORDENAR_POR_RIESGO
   ─────────────────
   Comparación: a->riesgo - b->riesgo
   Uso: Identificar individuos de alto/bajo riesgo
   Aplicación: Priorización en medidas de contención

2. ORDENAR_POR_TIEMPO
   ──────────────────
   Comparación: a->tiempo_infeccion - b->tiempo_infeccion
   Uso: Ordenar por días desde infección
   Aplicación: Seguimiento de progresión epidemiológica

3. ORDENAR_POR_NOMBRE
   ──────────────────
   Comparación: strcmp(a->nombre, b->nombre)
   Uso: Ordenamiento alfabético
   Aplicación: Búsqueda y auditoría de datos

================================================================================
                            FUNCIÓN DE PRUEBA
================================================================================

test_analisis_datos(Individuo *poblacion, int num_individuos)

Realiza 3 pruebas, cada una ordena la población con los 3 algoritmos:

PRUEBA 1: Ordenar por RIESGO
  - Muestra los 5 primeros individuos (menor riesgo)
  - Verifica que MergeSort, QuickSort y HeapSort producen resultados consistentes
  - Complejidad: 3 * O(n log n) = O(n log n)

PRUEBA 2: Ordenar por TIEMPO DE INFECCION
  - Muestra los 5 últimos infectados (mayor tiempo)
  - Identifica casos más antiguos de infección
  - Complejidad: 3 * O(n log n) = O(n log n)

PRUEBA 3: Ordenar por NOMBRE (alfabético)
  - Muestra los 5 primeros por nombre
  - Verifica consistencia alfabética
  - Complejidad: 3 * O(n log n) = O(n log n)

Complejidad Total de test_analisis_datos: O(n log n)

================================================================================
                        RESULTADOS DE EJECUCION
================================================================================

Input: 1000 individuos con:
  - Riesgos: 0-99 (aleatorio)
  - Tiempos de infección: 0-1 (10 pacientes cero, 990 sanos)
  - Nombres: Individuo_0 a Individuo_999

Salida Prueba 1 (Riesgo):
  MergeSort:  Individuo_30 (riesgo=0), Individuo_35 (riesgo=0), ...
  QuickSort:  Individuo_976 (riesgo=0), Individuo_30 (riesgo=0), ...
  HeapSort:   Individuo_30 (riesgo=0), Individuo_976 (riesgo=0), ...

Salida Prueba 2 (Tiempo):
  MergeSort:  Individuo_456 (t=1), Individuo_574 (t=1), ...
  QuickSort:  Individuo_574 (t=1), Individuo_878 (t=1), ...
  HeapSort:   Individuo_361 (t=1), Individuo_172 (t=1), ...

Salida Prueba 3 (Nombre):
  MergeSort:  Individuo_0, Individuo_1, Individuo_10, Individuo_100, ...
  QuickSort:  Individuo_0, Individuo_1, Individuo_10, Individuo_100, ...
  HeapSort:   Individuo_0, Individuo_1, Individuo_10, Individuo_100, ...

Observación: Los tres algoritmos producen ordenamientos válidos.
Los órdenes pueden variar dentro del mismo criterio (estabilidad) pero
todos respetan el criterio de comparación.

================================================================================
                            ANALISIS COMPARATIVO
================================================================================

MERGESORT vs QUICKSORT vs HEAPSORT

┌─────────────┬──────────────┬──────────────┬──────────────┐
│ Criterio    │ MergeSort    │ QuickSort    │ HeapSort     │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ Mejor caso  │ O(n log n)   │ O(n log n)   │ O(n log n)   │
│ Caso prom.  │ O(n log n)   │ O(n log n)   │ O(n log n)   │
│ Peor caso   │ O(n log n)   │ O(n²)        │ O(n log n)   │
│ Espacio     │ O(n)         │ O(log n)     │ O(1)         │
│ Estabilidad │ Sí           │ No           │ No           │
│ In-place    │ No           │ Sí           │ Sí           │
│ Cache-opt.  │ Bueno        │ Excelente    │ Pobre        │
│ Uso práctico│ Datos grandes│ Propósito gral│ Tiempo pred. │
└─────────────┴──────────────┴──────────────┴──────────────┘

RECOMENDACIONES:

1. Para datasets epidemiológicos GRANDES (> 10k registros):
   → QuickSort (mejor rendimiento en práctica)

2. Para garantías de tiempo DURO (tiempo real):
   → MergeSort o HeapSort (ambos O(n log n))

3. Para memoria LIMITADA:
   → HeapSort (O(1) espacio adicional)

4. Para estabilidad IMPORTANTE (mantener orden original):
   → MergeSort (solo algoritmo estable)

5. Para propósito GENERAL (mejor balance):
   → QuickSort (usado en std::sort, qsort de C)

================================================================================
                        COMPLEJIDAD BIG-O RESUMIDA
================================================================================

FUNCIONES CRITICAS:

1. comparar_individuos()
   Complejidad: O(1) para riesgo y tiempo, O(L) para nombre
   donde L = longitud promedio del nombre
   En práctica: O(1) (nombres son cortos, ~12 caracteres)

2. merge_sort() / quick_sort()
   Complejidad: O(n log n)
   Dominante: Comparaciones y movimientos

3. heap_sort()
   Complejidad: O(n log n)
   Construcción heap: O(n)
   Extracción: O(n log n) = sum(log i para i de 1 a n)

4. test_analisis_datos()
   Complejidad: O(3 * (3 * n log n)) = O(n log n)
   - 3 pruebas × 3 algoritmos × O(n log n) cada uno
   - Copia de datos: O(3 * n) = O(n)
   - Factor constante 9 es amortizado

LINEA DE FONDO: Todas las operaciones principales están en O(n log n)

================================================================================
                          PROXIMOS PASOS
================================================================================

✓ Subproblema 1: COMPLETADO Y VERIFICADO

Próximo: Implementar Subproblema 2 (Detección de Brotes)
  - Usar BFS/DFS para encontrar componentes conectadas
  - Complejidad: O(V + E) < O(n³)
  - Identificar clusters de infectados

================================================================================
